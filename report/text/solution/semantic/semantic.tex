\chapter{Semantic Analyser}

The semantic analyser checks for errors that the lexer and the parser do not catch. The semantic analyser for the language has the following requirements to be able to generate the expected slide.

\section{Requirements}
\begin{itemize}
	\item Check that the user defined keyword exists in the language.
	\item Check that the setting in the setting block exists.
	\item Check that it is a valid input after the colon in a setting block.
	\item Check that it is a valid scope on the right side of the pipe in a setting block.
	\item Check that the transition exists in a begin block.
	\item Check which number to put in to the enumeration.
\end{itemize}

\noindent{These requirements are put in to categories, with more explanation to specify the function of the semantic analyser.}

\section{Semantic Analysis for Text Formatting}

\subsection{Keyword Existence}
In order for the settings to work, a check to see if the given setting actually exists in that context is needed. In order to check if the setting exists, a list of settings for a given context is set up beforehand which it can be checked against. If the setting exists in the list the value of the setting is checked to see if it matches a valid value of that setting. If it does not exist, then an error is written to the user.


\subsection{Type Checking}
For a given setting there is a number of valid values, two examples could be the settings \texttt{font\_size} and \texttt{font\_weight} , which sets the size or weight of a given text. In the case of \texttt{font\_size}, a valid input would be any integer, and in the case of \texttt{font\_weight} it would be a valid string of a weight. As with the keyword, existence of an error is written if the value of the setting is not valid.
The type checking for integers and integers with decimals, is done by converting the value from a string to an int or float respectively.
Typechecking for specific strings is done with \texttt{if} sentences, if they do not match any, an error occures.
     
\subsection{Scope Checking}

\subsubsection*{Targeted text}
Every setting block has to be given a scope of what it is going to affect. An example could be \texttt{global}, which, for a given setting would set all types of text in the given effect level unless it is overridden at a later stage.

\subsubsection*{Effect Level}
When a setting block is inside a begin- and end block, the setting only affects that particular slide.
A setting block can also be used outside a slide, in which case that setting would apply to every slide following that setting unless overridden at a later stage. These scope settings have to be checked as to see what text that setting should apply to.

Listing \ref{LSTSemanticSetting} is a code example of when the compiler enters a setting node. Visibility word in this section means which font type is changed, eg. title, text, subtitle.

\begin{lstlisting}[frame=single,caption=SettingBlock, label=LSTSemanticSetting, language=java]
public void inASettingblock (ASettingblock node){
	String SettingType = node.getShortident().toString().trim();
	String Visability = node.getChar().toString().trim();
	String Test = node.parent().parent().getClass().toString();
	if (Test.equals("class nisse.node.ABlockBlocks")){
		//	System.out.println("Dette er en lokal variabel");
		if (SettingType.startsWith("@ font_color")){
			String Value = SettingType.substring(15);
			Boolean CheckColor1;
			CheckColor1 = CheckColor(Value);
			if (CheckColor1 == true){
				if (Visability.equals("global")){
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewTextFontColor] = Value;
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewTitleFontColor] = Value;					
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewSubtitleFontColor] = Value;
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewImageFontColor] = Value;
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewUrlFontColor] = Value;
				}
				else if (Visability.equals("text")){
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewTitleFontColor] = Value;
				}
				else if (Visability.equals("image")){
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewImageFontColor] = Value;
				}
				else if (Visability.equals("title")){
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewTitleFontColor] = Value;
				}
				else if (Visability.equals("subtitle")){
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewSubtitleFontColor] = Value;
				}
				else if (Visability.equals("url")){
					SymbolTable.Scope[SymbolTable.ScopeLevel][SymbolTable.NewUrlFontColor] = Value;
				}
    	  else {
    	    System.out.println("Visability word not recognized");
    	  }
    	}
    	else {
					System.out.println("Font color:" + Value + "could not be found, try a different one, or write only with small letters");
			}
		}
		else if (SettingType.startsWith("@ font_family")){	
			String Value = SettingType.substring(16);
		…...

\end{lstlisting}


Listing \ref{LSTSemanticSetting} illustrate setting typecheck, and changes parameters according to the visibility word, which is placed just before the right curly bracet in a setting block.\\
Line 2 fetches the setting, node \textit{Shortident}, it contains information about what setting to change and what to change it to, which is converted to a string and then the excess spaces are removed.\\
Line 3 fetches the visibility declaration, which is in the node \textit{Char}, which is also converted to a string a excess spaces are removed.\\
Line 4 finds out which class the setting block belongs to. This is necessary to determin if the setting block is inside or outside a slide. Which also is the first to be checked in line 5. An \textit{else} construction is made for this \textit{if} sentence which is executed when the setting should be applied on very upcomming slide.\\
Line 7 checks which keyword that is going to be changed, is this case it is \textit{Font\_Color}. The parameter is then stored in a string called \textit{Value}, which takes the substring of SettingType, starting a char 15. The reason it is 15 is because a space is added after each token. So there is a space after \textit{font\_color} and a space after the colon (:) which makes the parameter start at the 15'th char.\\
Because it is a color, it checks in the function \textit{CheckColor}, at line 9 to 11, if the color is allowed to be inseted. If it is not allowed, it will not change the color, and then skip to line 38.\\
From line 12 to 33 it check what the visibility keyword is. Depending on the word, it changes the parameter for that specific visibility.\\
Line 13 enters the document SymbolTable and the array \textit{Scope}, which insets the parameter at the current scope level, and in the cell containing the information about text font color.\\


\section{Semantic Analysis for Blocks}
This section focuses on blocks. A block consists of at least two lines, a \texttt{begin} line and an \texttt{end} line.
Between those two lines, information can be stored.
The generic setup for the two lines are shown in section \ref{@begin} and \ref{@end}.

    \subsection{Transition Existence}
In order for the compiler to apply a transition on a slide, the analyser has to check if the transition that is written exists in the database of transitions. If the transition does not exist an error has to occur. If the transition does exist, then it continues without error.

%    \subsection{Type Checking}
%The type checking in a begin- and end line consists of checking that between the two brackets is the word \texttt{slide}. In special cases, where a transition is on a slide, the word \texttt{slide} must be between the pipe and the right bracket. The word seems redundant because no other word can be in its place at this time. But for further development, where a begin- and end line can do more than just enclose a slide, this will come in handy.

\subsection{Slide type checking}
There are diffent type of slide layouts. For instance most slide presentations starts with a title slide, with or without a subtitle. This frontpage has its' title and if subtitle, is in the middle of the slide. Instead of giving the user the explicit choice of this. The semantic analyser will check this, and create the correct type of slide according to the textinput from the user.


\begin{lstlisting}[frame=single,caption=Function: OutBlockBlocks, label=LSTOutBlockBlocks, language=java]
public void outABlockBlocks (ABlockBlocks node){
		String Transition = node.getBeginblock().toString();
		Transition = Transition.substring(9);
		String Transition1 = "none";
		if (Transition.startsWith("slide")){
		}
		else if (Transition.startsWith("fade")){
			Transition1 = "fade";
		}
		else if (Transition.startsWith("swipe")){
			Transition1 = "swipe";
		}
		else if (Transition.startsWith("scale")){
			Transition1 = "scale";
		}
		else if (Transition.startsWith("rotatescale")){
			Transition1 = "rotatescale";
		}
		String SlideType = "Unknown";
		Object[] Slide = node.getLines().toArray();
		int Lines = Slide.length;
		int i = 0;
		int title = 0;
		int subtitle = 0;
		int image = 0;
		while(i<Lines){
			String Slide1 = Slide[i].toString();
			if (Slide1.startsWith("@setting")  ||  Slide1.startsWith("@note")){
			}
			else if (Slide1.startsWith("@title") ) {
				title++;
			}
			else if (Slide1.startsWith("@subtitle") ) {
				subtitle++;
			}
			else if (Slide1.startsWith("@image") ) {
				image++;
			}
			else {
				SlideType = "Normal";
				SymbolTable.SlideTableAdd(SlideType, Transition1);
				indent--;
				return;
			}
			i++;
		}
		if (title > 0 && subtitle == 0 && image == 0){
			SlideType = "Title";
		}
		else if (title > 0 && subtitle > 0 && image == 0){
			SlideType = "TitleWithSubtitle";
		}
		else if (image > 0){
			SlideType = "Image";
		}		
		SymbolTable.SlideTableAdd(SlideType, Transition1);
	}
\end{lstlisting}

\subsection{Transition Existence}
In listing \ref{LSTOutBlockBlocks} from line 2 to 18 the function finds out if and what transition the slide has. In line 2 it creates the \texttt{@begin} line to a string, which can be operated on. In line 3 it creates a substring of line 2 beginning at char 9 which is where the transition should be written if any. Line 4 sets the transition to \texttt{none}. From line 5 it checks if the transition is \texttt{slide}, in this case there are no transition and the transition remains to be \texttt{none}. From line 10 to 18 it checks which kind of transition it is, and sets it to the found transition, if the transition is not found, the slide will have none.\\
\subsection{Slide type checking}
In listing \ref{LSTOutBlockBlocks} from line 19 to 54, we find out which type the slide it is. It starts by being \texttt{Unknown}, but it should never be that in the end. Then in line 20 it

\section{Semantic Analysis for Other Keywords}
\subsection{Image}
\texttt{Image} has to check if there exists an image on that specific url. If no image is found, accessible or in a format that is not recognized by the compiler, an error should occur.



\subsection{Enumerate}
The hash tag keyword has to keep track of the numbers, meaning that it has to increment each time a line starts with a hash tag. And when a line does not start with a hash tag, the number should start from one again. This is also applicable where hash tags are inside hash tags.

(Bliver checket i code gen)

\section{Exception Handling}




\section{Reachability and Termination Analysis}
There is no need to check for unreachable code in the language, because there are no breakers in the language e.g. return, break, exit, etc.
This also means that the language always terminates normally, because there are no keywords to stop a normal termination.



\section{SymbolTable}

in order to know the properties for each token that is written by the user, a symbol is added to the symbol table, containing the necessary information for the code generator to display the token correctly.

\begin{lstlisting}[frame=single,caption=Function: Function: SymbolTableAdd, label=LSTSemanticSymbolTableAdd]
public static void SymbolTableAdd(String Text, String Type, String FontSize, String FontFamily,String FontColor, String FontLineheight, String FontWeight, String Link){
String[] Values = {Text, Type, FontSize, FontFamily, FontColor, FontLineheight, FontWeight, Link};
SymbolTable1.put(GetCurrentSymbolNumber(), Values);
NextSymbolNumber();
}
\end{lstlisting}

Listing \ref{LSTSemanticSymbolTableAdd} shows the function called to create a symbol in the symbol table. It stores all the variables in an array which is inside a hashtable. Each hash entry has unique number in order to fetch the entry. before the function ends the number is incremented by 1, which is the next unique hashkey.


\section{SlideTable}
An additional table is created to keep track of the overall properties in a slide, meaning the transition between the slides, and which type of slide it is, eg. a title page or a normal page.
The slide type is determined in listing \ref{LSTOutBlockBlocks}. In line 56 in listing \ref{LSTOutBlockBlocks}, it calls the function SlideTableAdd, which is shown in listing \ref{LSTSlideTableAdd}. Where the transition at the beginning is set to \texttt{none}, but can be modified in the function \texttt{outABlockBlocks} in listing \ref{LSTOutBlockBlocks}. The slide table looks more or like the symbol table, only with fewer elements in the array.

\begin{lstlisting}[frame=single,caption=Function: Function: SlideTableAdd, label=LSTSlideTableAdd]
static String Transition = "none";

public static void SlideTableAdd(String Type, String Transition){
			String[] Values = {Type, Transition};
			SymbolTableForSlide.put(GetSlideNumber(), Values);
			NextSlide();
		}  
\end{lstlisting}