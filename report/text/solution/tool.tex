\chapter{Lexer and Parser Generation}
In this chapter a number of lexer and parser generators will be presented, in order to determine the best generator for our project.

\noindent{The lexer and parser can be made manually or generated automatically with a number of different generators. The advantage of having the lexer and parser generated by a generator is that changes in the CFG (Context Free Grammar) can easily be implemented and checked compared to doing this manually. This will be useful when expanding the possibilities in the language, which is why a generator will be used to generate the lexer and parser.}

%\section{SableCC}
%A SableCC file consists of six optional sections, Package, Helpers, States, Tokens, Ignored Tokens and Productions.
%Package indicates what package the generated files should be under. Helpers are either character sets or regular expressions denoted by an identifier. Helpers can only be used in Tokens. States are used to switch between states, but are not used in this project. Tokens are defined much like Helpers. The lexer will return the longest matching token or the token listed first in Tokens if two or more tokens is matched of the same length. Ignored Tokens are tokens that are not returned by the lexer. Finally Productions are the normal production rules of the grammar, although an identifier has to be given for every alternative to a production rule, and an identifier has to be given when more then one occurrence of a production rule or token is in a given alternative.

\section{SableCC}
\label{sec:SableCC}
SableCC is a lexer and parser generator. As its input it takes an extended EBNF (Extended Backus–Naur Form) grammar. In order for the grammar to be accepted, the grammar has to be LALR(1), as that is the kind of parser SableCC makes. A feature of SableCC is that it can separate the generated code, from the developer's code, which makes it easy to update the compiler, as code does not have to be moved. SableCC also provides a visitor pattern to traverse the parse tree that the parser generates; this makes it easier to make the semantic analyser and the code generator.\\
A SableCC file consists of six optional sections; \texttt{package}, \texttt{helpers}, \texttt{states}, \texttt{tokens}, \texttt{ignored tokens} and \texttt{productions}.\\
\texttt{Package} indicates what package the generated files should be made using. \\
\texttt{Helpers} are either character sets or regular expressions denoted by an identifier. Helpers can only be used in \texttt{Tokens.} \\
\texttt{States} are used to switch between states, but are not used in this project. \\
\texttt{Tokens} are defined much like \texttt{Helpers}. The lexer will return the longest matching token or the token listed first in tokens if two or more tokens are matched of the same length. \\
\texttt{Ignored Tokens} are tokens that are not returned by the lexer. \\
Finally, productions are the normal production rules of the grammar, although an identifier has to be given for every alternative to a production rule, and an identifier has to be given when more than one occurrence of a production rule or token is in a given alternative.\\

\section{JavaCC}
Something Something

\section{Conclusion}
SableCC has been chosen as the lexer and parser generator, because it takes an extended EBNF grammar, which is easy to translate to from NISSE's grammar which is written in EBNF. SableCC also includes a visitor pattern, which makes it much easier to not get slowed down by not having to write the visitor pattern for all of our production rules. A SableCC specification file is also simple and easy to get started with.
