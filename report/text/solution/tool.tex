\chapter{Lexer and Parser Generation}
In this chapter a number of lexer and parser generators will be presented, in order to determine the best generator for the project.

\noindent{The lexer and parser can be made manually or generated automatically with a number of different generators. The advantage of having the lexer and parser generated by a generator is that changes in the CFG (Context Free Grammar) can easily be implemented and checked compared to doing this manually. This will be useful when expanding the possibilities in the language, which is why a generator will be used to generate the lexer and parser.}

\section{SableCC}
\label{sec:SableCC}
SableCC is a lexer and parser generator. As its input it takes an extended EBNF (Extended Backus–Naur Form) grammar. In order for the grammar to be accepted, the grammar has to be LALR(1), which is the kind of parser SableCC makes. A feature of SableCC is that it can separate the generated code, from the developer's code, which makes it easy to update the compiler, as code does not have to be moved. SableCC also provides a visitor pattern to traverse the parse tree that the parser generates; this makes it easier to make the semantic analyser and the code generator.\\
A SableCC file consists of six optional sections; \texttt{package}, \texttt{helpers}, \texttt{states}, \texttt{tokens}, \texttt{ignored tokens} and \texttt{productions}.\\
\begin{itemize}
\item \texttt{Package} indicates what package the generated files should be made using. \\
\item \texttt{Helpers} are either character sets or regular expressions denoted by an identifier. Helpers can only be used in \texttt{Tokens.} \\
\item \texttt{States} are used to switch between states. \\
\item \texttt{Tokens} are defined much like \texttt{Helpers}. The lexer will return the longest matching token or the token listed first in tokens if two or more tokens of the same length, are matched. \\
\item \texttt{Ignored Tokens} are tokens that are not returned by the lexer. \\
\end{itemize}
Finally, \texttt{Productions} are the normal production rules of the grammar, although an identifier has to be given for every alternative to a production rule, and an identifier has to be given when more than one occurrence of a production rule or token is in a given alternative.\\

\section{JavaCC}
JavaCC is a lexer and parser generator. As its input it takes a EBNF grammar. However it is not in the form of a normal EBNF. It is in a special form derived from the Java syntax that looks a little like a Java method definition. An example of token definitions and production rules is given in listing \ref{lst:JavaCC}

\begin{lstlisting}[frame=single, caption=JavaCC token and production specification, label={lst:JavaCC}]
TOKEN : { < PLUS : ?+? > }
TOKEN : { < NUMBER : ([?0?-?9?])+ > }
void Start() :
{
	<NUMBER>
	(
		<PLUS>
		<NUMBER>
	)*
	<EOF>
}
\end{lstlisting} 
\noindent{The example shows that the form is far from the original form of EBNF, but it is still readable as the production is named \texttt{Start} and the rule is that a \texttt{NUMBER} token is followed by none or more \texttt{PLUS NUMBER} token sequences. In the language specification JavaCC can also take some amount of action code, so that part of the code generator is also specified there.}

\section{Conclusion}
SableCC has been chosen as the lexer and parser generator, because it takes an extended EBNF grammar, which is easy to translate to, from NISSE's grammar which is written in EBNF. SableCC also includes a visitor pattern, which makes it much easier to not get slowed down by not having to write the visitor pattern for all of the production rules of this project. A SableCC specification file is also simple and easy to get started with.
